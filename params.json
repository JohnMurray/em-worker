{"google":"","name":"EM-Worker","tagline":"Worker framework using EventMachine","body":"So right now, this is really all just an idea that I'm trying to\r\nthink through and see if it's really worth it or not. So, here's\r\nwhat I got.\r\n\r\n## Problem\r\n\r\nYou need to run some type of task over and over again (let's assume\r\ncontinuously w/o stop). How do you go about doing it? If it sits\r\nbehind a queue then you're in luck. There are many queue processing\r\nlibraries out there. However, let's assume that you're not sitting behind\r\na queue and you're not using a queue processing library. How would you\r\ngo about solving the problem?\r\n\r\nFor the sake of demonstration, let's use the following problem:\r\n\r\n```text\r\nYou are creating a new social network (that's just what the world\r\nneeds) and you want to create an activity stream. To solve the problem\r\nof sharing, you've implemented a model such that your items are pushed\r\ninto the stream in an \"unpublished\" state. \r\n\r\nYou then have a process which will (periodically) collect all unpublished\r\nitems and push them to the user's friends' streams (based on said user's\r\nprivacy settings). That's really not that bad of a model to be honest\r\n(seems to be how etsy does it).\r\n```\r\n\r\nHow do you implement this process? Cron tasks? If so, how would you\r\ndeploy this on something like Heroku? Would you use their cron plugin?\r\nIf so, then you're really limiting yourself to scaling up to aggregate/\r\nprocess more data. \r\n\r\n\r\n## Solution\r\n\r\nI think a valid option is to use a framework like EventMachine where you\r\ncan schedule tasks to be run (on a timer, the next tick, etc.) and you\r\ndon't have to rely on any type of cron. There are lots of projects that\r\nuse this model.\r\n\r\n\r\n\r\n## A Better Solution\r\n\r\nGiven that I feel like this is a common problem, shouldn't someone make\r\nsomething that makes all of this a little easier (for EM)? That's what\r\nI am talking about! How can we go about making a framework for writing\r\n\"workers\" that uses eventmachine and extracts all of the nasty\r\nsetup/implementation details that go along with creating a service like\r\nthis in EventMachine?\r\n\r\n\r\n## An Idea\r\n\r\nA library (gem) that extracts the running and scheduling of the worker\r\nprocesses. It would basically be a single class that looked something\r\nlike:\r\n\r\n```ruby\r\nclass MyWorker < EM::Worker\r\n  def do_work\r\n    # gets called continuously\r\n  end\r\nend\r\n```\r\n\r\nThere is just one method that executes and then is scheduled to run\r\nagain. There could also be some type of scheduler that determines\r\nwhen a worker should be run. The default scheduler that runs something\r\ncontinuously might look like:\r\n```ruby\r\nclass EM::WorkerScheduler\r\n  def initialize(workers)\r\n    @workers = workers\r\n  end\r\n\r\n  def run\r\n    @workers.each do |worker|\r\n      EM.next_tick do\r\n        worker.run!\r\n      end\r\n    end\r\n  end\r\nend\r\n\r\nclass EM::Worker\r\n  def run!\r\n    do_work\r\n    EM.next_tick(&method(:do_work))\r\n  end\r\nend\r\n```\r\n\r\nI'm sure there's something wrong here that doesn't work but you \r\nget the point. The scheduler starts a worker task and that worker\r\nthen performs it's work and runs the `do_work` method and schedules\r\nitself again for the next available tick. \r\n\r\nObviously there could be many diffeent types of schedulers you could\r\npick an choose from. You could also implement your own scheduler (I\r\nwould imagine) very easily.\r\n\r\n\r\n\r\n## Advantages?\r\nSo, what would the real advantage be? If we're talking about\r\ncontinuously running processes or things that run on a timer, then I'm\r\nnot sure there is too much of an advantage to that. The equivalent EM\r\ncode would be really simple as well. I see there being two main\r\nadvantages:\r\n\r\n+ Throttling/Scaling Scheduler\r\n+ Running in _Standalone_ mode\r\n\r\n\r\n### Throtting/Scaling Scheduler\r\n\r\n### Standalone Mode\r\nI imagine standalone mode would just be some way to run it without having\r\nto include EM explicitely such like:\r\n\r\n```ruby\r\n# File my_worker.rb\r\nclass MyWorker < EM::Worker\r\n  set_scheduler :continuous\r\n  \r\n  def do_work\r\n    # ... some task ...\r\n  end\r\nend\r\n```\r\n\r\nAnd you could start it like:\r\n```bash\r\n# start it with a provided binary\r\nworker my_worker.rb\r\n```\r\n\r\nOr you could start it in Ruby like:\r\n```ruby\r\n# main.rb (or something)\r\nrequire './my_worker'\r\n\r\nMyWorker.standalone!\r\n```\r\n\r\n\r\n## Suggestions?\r\n\r\nTell me what you think: me@johnmurray.io\r\n","note":"Don't delete this file! It's used internally to help with page regeneration."}